---
layout: single
title:  "拒绝设计模式，UML, 以及面向对象"
categories: Misc
---

编程初学者，和误入歧途者容易遇到的认识论问题

## 拒绝设计模式
自从GoF(Gang of Four)发表了《设计模式：可复用面向对象软件的基础》这本书，很多Java程序员就陷入了23种模式中，看万物都是模式。实际上在没有这些模式之前，那些软件过得也很好；有了这些模式之后，深信模式的某些人，开始拿着这23种模式这种锤子到处找钉子去了。

这肯定是《那些年害过我们的技术套路》之首了。或许你精通无数对模式的事后阐述，但这些模式对多变的工程需求没什么指导意义，华而不实。

你搞个单例模式，明明就是一个全局 const变量搞定的东西，为啥起个那么复杂的名字？换个马甲我还认识你！

工厂模式，明明就是 constructor方法构造一个新的变量而已。我不用这些模式比用了模式写的更快更好，你跟我扯这些高大上的名词，有什么意思？别整那些没用的。。

## 面向对象害人
封装、继承、多态。

面向对象是上世纪很古老的程序语言方案，21世纪几乎所有语言都可以面向对象。即便是 C语言也能通过复杂的编码实现这些特性，只是没有落实到语言 built-in上。

深信面向对象的人，认为世界一切都是对象，到处继承，认为有个 BaseObject是万物的起源。但是离散的现实世界中，一个电冰箱，与另一个猫或狗之间，并没有直接关联。即便猫、狗、动物间有某种生物关联，继承也不是必要的语言 built-in选项，完全可以通过其他方式说明猫狗之间的某种特殊关系，比如一个哺乳动物的有限集合。而对于一个 number来说，它就是个简单的整形或浮点型变量，假如他是一个 Object, 那其他的 to_string() 方法是可选的。不是所有的变量都需要 to_string() 成员方法。不断地继承无用的成员方法，会让 Object Instance不断地膨胀，直到最后的 Object背负了无数 member method包袱，造成重构困难，高度耦合。

工程上，“封装”才是进行“过程抽象”解除耦合最重要的工具，封装只开放 public接口，从而屏蔽了内部实现细节。而“数据抽象”则可以依靠类似 class/struct的 data combine实现。

总之，面向对象只是告诉你可以面向，而不是必须面向。如果你的项目里到处 Manager, Woker, Connector, BaseXXX, SubXXX, 那肯定出问题了，代码通了人性，充斥着农奴主义的味道。

## UML
这种古老的开发概念恐怕已经落后时代太久。尤其是靠 UML生成代码的，肯定没什么好结果。程序就是需要自由，以适应当今多变，灵活的项目需求。一旦僵化成工具生成，人工填鸭，项目离失败不远了。不过用作事后归纳总结，做个漂亮的PPT，给不明真相的围观群众吃瓜，还是挺好的。

## 一次编译，到处运行
这种方案建立在强大的字节码虚拟机之上，效率堪忧。仅是PPT里给投资方放的一个广告。每次打开Java应用，我都会被那 500M+的内存占用的恐惧支配着。低效的跨平台移植毫无意义，智能设备时代只能由 C/C++这种系统语言处理。更多的系统，没有平台移植需求。

## Golang & Rust
Golang v1.x 语法简单，上手快速, 易学易用，内置简洁易懂的 CSP模型的 goroutine + channel。但语言特性过于简单，信息内聚性差，代码上不那么漂亮。这提供了它快速占领 Web开发市场的优势。后续 v2.0版本可能会趋向于 Rust与 C++ 。我认为它是种易用的C语言，以及事实上的 Web开发语言。

Rust 语法复杂，有在realtime领域替代C++的趋势。


