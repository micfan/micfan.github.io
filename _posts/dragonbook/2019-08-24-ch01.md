---
layout: single
title:  "第01章  编译器结构"
tags: compiler
categories: dragonbook
---
第01章  编译器结构

## 1.1 节练习

### 1.1.1
编译器 读入源代码文件，把其翻译为另一编程语言的目标程序，由该目标程序接受用户输入;

解释器 不翻译源文件为某种语言的目标程序，而是直接接受用户输入，并解释执行源代码文件

### 1.1.2
编译器 如果生成机器码，执行速度比 解释器 快

解释器 的错误诊断效果比 编译器 好，因为它逐个语句地执行源程序

### 1.1.3
编译器产生汇编语言好处是，汇编语言比较容易输出和调试。并可由`汇编器`生成可重定位的机器代码

### 1.1.4
C语言，其自身优点是，比汇编语言抽象程度高，更便于输出和调试。使用C语言作为目标语言，可以利用现有C语言编译器，如 GCC，CLANG等，达到编程语言架构分层的效果：

源语言 -> C语言 -> 汇编语言 -> 机器语言

### 1.1.4
汇编器的任务：把汇编语言源文件翻译成，可重定位的机器代码，供`链接器`把可重定位的机器代码，与其他可重定位的目标文件，以及库文件连接到一起



## 1.3 节练习

### 1.3.1

强制式： C, C++, Java

声明式： ML, Haskell, Prolog

冯诺伊曼： Fortran, C

OO: C++, Java, Python, C#, Ruby

函数式： Lisp, Python(非纯函数式), ML(非纯函数式)

第一代： 机器语言

第二代： 汇编语言

第三代： Fortran, Cobol, Lisp, C, C++, C#, Java 等高级程序设计语言

第四代： 特定应用语言，如 SQL, Latex, Postscript,

第五代： 基于逻辑和约束的语言，如 Prolog, OPS5



## 1.6 节练习

### 1.6.1
```
w: 13 = 6 + 7

x: 11 = 6 + 5

y: 13 = 8 + 5

z: 11 = 6 + 5
```

### 1.6.2
```
w: 9 = 5 + 4

x: 7 = 3 + 4

y: 13 = 7 + 6

z: 11 = 7 + 4
```

### 1.6.3
todo


### 1.6.4 C code output
```c
#define a (x + 1)
int x = 2;
void b() { x = a; printf("%d\n", x); }
void c() { int x = 1; printf("%d\n", a); }
void main () { b(); c(); }
```

```bash
3

2
```

解释： Line:1 的宏定义，在预处理器预处理后，替换了下文代码 Line:3, Line:4 中的 `a`字符。
为了解析 `x`, 必须使用`动态作用域`规则，检查当期活跃的函数调用，然后选择最近调用的，且具有一个
对 `x`的声明的函数。对 `x`的使用就指向这个声明。

预处理结果如：

```c
#define a (x + 1)
int x = 2;
void b() { x = (x + 1); printf("%d\n", x); } // x: 3 = 2 + 1
void c() { int x = 1; printf("%d\n", (x + 1)); } // (x +1): 2 = 1 + 1
void main () { b(); c(); }
```